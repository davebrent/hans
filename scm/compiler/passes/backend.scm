(define-module (hans compiler passes backend)
  :use-module (srfi srfi-1)
  :use-module (hans common)
  :use-module (hans compiler shared)
  :use-module (hans patcher)
  :use-module (hans objects)
  :use-module (hans utils)
  :export (emit-libraries
           emit-objects
           emit-objects-state
           emit-arguments
           emit-parameters
           emit-parameters-values
           emit-modulators
           emit-chains
           emit-programs
           emit-registers
           emit-fbos
           emit-fbos-attachments
           emit-shaders
           emit-ring-buffers
           emit-audio-buffers
           make-strings
           backend-pass))

(define (%flatten lst)
  (fold (lambda (item out) (append out item)) '() lst))

(define (%list-parameters programs)
  (%flatten (map (lambda (obj)
                   (map (lambda (parameter)
                          (cons (hans-object-instance-id obj)
                                parameter))
                        (object-record-parameters (hans-object-rec obj))))
                  (list-objects programs))))

(define (%list-fbos programs)
  (fold (lambda (obj fbos)
          (let ((rec (hans-object-rec obj)))
            (if (and (graphics-object? rec)
                     (not (eq? '() (object-record-fbo rec))))
              (append fbos `(,(cons obj (object-record-fbo rec))))
              fbos)))
        '()
        (list-objects programs)))

(define (%list-registers programs)
  (%flatten (map (lambda (obj)
                   (let ((registers (hans-object-registers obj)))
                     (map (lambda (register)
                          (cons obj register))
                        (if (eq? #f registers) '() registers))))
                 (list-objects programs))))

;; Emitter functions have the signature:
;;   (programs) -> (cons (list hans-primitive ...) (list string ...))

(define (emit-libraries programs)
  (let ((libraries (list-libraries programs)))
    (cons (map (lambda (lib)
                 `((filepath . ,(hans-hash lib))))
               libraries)
          libraries)))

(define (emit-objects programs)
  (let ((objects (list-objects programs)))
    (cons (map (lambda (obj)
                 (let* ((rec (hans-object-rec obj))
                        (id  (hans-object-instance-id obj))
                        (type (object-record-type rec)))
                   `((id   . ,id)
                     (type . ,(hans-primitive-enum 'OBJECTS type))
                     (name . ,(hans-hash (object-record-name rec))))))
               objects)
          (map (compose object-record-name hans-object-rec) objects))))

(define (%tag-pair arg)
  (cond ((or (string? (cdr arg)) (symbol? (cdr arg)))
          `((type    . ,(hans-primitive-enum 'ARGUMENTS 'string))
            (name    . ,(hans-hash (car arg)))
            (boolean . #f)
            (number  . 0)
            (string  . ,(hans-hash (cdr arg)))))
        ((number? (cdr arg))
          `((type    . ,(hans-primitive-enum 'ARGUMENTS 'number))
            (name    . ,(hans-hash (car arg)))
            (boolean . #f)
            (number  . ,(cdr arg))
            (string  . 0)))
        ((boolean? (cdr arg))
          `((type    . ,(hans-primitive-enum 'ARGUMENTS 'boolean))
            (name    . ,(hans-hash (car arg)))
            (boolean . ,(cdr arg))
            (number  . 0)
            (string  . 0)))))

(define (emit-arguments programs)
  (cons (fold (lambda (obj result)
                (let* ((arguments (assq-ref result 'arguments))
                       (lengths (assq-ref result 'lengths))
                       (offsets (assq-ref result 'offsets))
                       (args (hans-object-args obj))
                       (tags (map %tag-pair args)))
                    `((arguments . ,(append arguments tags))
                      (offsets   . ,(append offsets `(,(length arguments))))
                      (lengths   . ,(append lengths `(,(length args)))))))
          `((arguments . ())
            (offsets   . ())
            (lengths   . ()))
          (list-objects programs))
        (fold (lambda (obj strs)
              (append strs (filter string? (map cdr (hans-object-args obj)))
                            (map (compose symbol->string car)
                                 (hans-object-args obj))))
            '()
            (list-objects programs))))

(define (emit-objects-state programs)
  (cons (map (lambda (obj)
               (hans-object-data obj))
             (list-objects programs))
        '()))

(define (emit-parameters-values programs)
  (cons (%flatten (map (lambda (data)
                         (parameter-value (cdr data)))
                       (%list-parameters programs)))
        '()))

(define (emit-parameters programs)
  (cons
    (let ((offset 0))
      (map (lambda (data)
             (let* ((param (cdr data))
                    (size  (parameter-components param))
                    (out   `((object . ,(car data))
                             (name   . ,(hans-hash (parameter-name param)))
                             (size   . ,size)
                             (offset . ,(parameter-components param)))))
               (set! offset (+ offset size))
               out))
           (%list-parameters programs)))
    (delete-duplicates (map (compose symbol->string parameter-name cdr)
                            (%list-parameters programs)))))

(define (emit-modulators programs)
  (define (transform-mod mod)
    `((source . (
        (object    . ,(hans-object-instance-id (list-ref mod 0)))
        (parameter . ,(hans-hash (list-ref mod 1)))
        (component . ,(list-ref mod 2))))
      (dest   . (
        (object    . ,(hans-object-instance-id (list-ref mod 3)))
        (parameter . ,(hans-hash (list-ref mod 4)))
        (component . ,(list-ref mod 5))))
      (offset . ,(list-ref mod 6))
      (scale  . ,(list-ref mod 7))))

  (cons (fold (lambda (program prev)
                (let ((modulators (hans-program-modulators program)))
                  (append prev (map transform-mod modulators))))
              '()
              programs)
        '()))

(define (emit-chains programs)
  (cons (%flatten (map (lambda (pgm)
                         (append (map hans-object-instance-id
                                      (hans-graph-objects
                                        (hans-program-audio-graph pgm)))
                                 (map hans-object-instance-id
                                      (hans-graph-objects
                                        (hans-program-graphics-graph pgm)))))
                       programs))
        '()))

(define (emit-programs programs)
  (define offset 0)

  (define (push-graph graph)
    (let* ((start offset)
           (objects (hans-graph-objects graph))
           (end (+ start (length objects))))
      (set! offset (length objects))
      (if (eq? (length objects) 0)
        '()
        `(,(hans-graph-id graph) ,start ,end))))

  (define (graph->chain graph)
    (if (eq? 0 (length graph))
      `((id    . ,0)
        (start . ,(+ 1 offset))
        (end   . ,(+ 1 offset)))
      `((id    . ,(list-ref graph 0))
        (start . ,(list-ref graph 1))
        (end   . ,(list-ref graph 2)))))

  (cons (map (lambda (pgm)
               (let ((snd-graph (push-graph (hans-program-audio-graph pgm)))
                     (gfx-graph (push-graph (hans-program-graphics-graph pgm))))
                 `((name     . ,(hans-hash (hans-program-name pgm)))
                   (graphics . ,(graph->chain gfx-graph))
                   (audio    . ,(graph->chain snd-graph)))))
             programs)
        (map hans-program-name programs)))

(define (emit-registers programs)
  (cons (map (lambda (data)
               (let* ((obj (car data))
                      (reg (cdr data))
                      (id (hans-object-instance-id obj))
                      (rec (hans-object-rec obj))
                      (type (object-record-type rec)))
                `((object   . ,id)
                  (type     . ,(hans-primitive-enum 'OBJECTS type))
                  (graph    . ,(list-ref reg 0))
                  (index    . ,(list-ref reg 1))
                  (bin      . ,(list-ref reg 2))
                  (readonly . ,(list-ref reg 3)))))
             (%list-registers programs))
        '()))

(define (emit-fbos-attachments programs)
  (define output '())
  (for-each (lambda (data)
              (let* ((obj (car data))
                     (fbo (cdr data))
                     (rec (hans-object-rec obj))
                     (id (hans-object-instance-id obj))
                     (type (object-record-type rec)))
                (set! output (append output (map
                  (lambda (attachment)
                    `((type       . ,(hans-primitive-enum
                                       'FBO_ATTACHMENTS
                                       (fbo-attachment-type attachment)))
                      (width      . ,(fbo-attachment-width attachment))
                      (height     . ,(fbo-attachment-height attachment))
                      (components . ,(fbo-attachment-components attachment))))
                  (fbo-attachments fbo))))))
            (%list-fbos programs))
  (cons output '()))

(define (emit-fbos programs)
  (define offset 0)
  (cons (map (lambda (data)
               (let* ((obj (car data))
                      (id (hans-object-instance-id obj))
                      (fbo (cdr data))
                      (num (length (fbo-attachments fbo)))
                      (out `((object         . ,id)
                             (stencil_buffer . ,(fbo-stencil-buffer fbo))
                             (start          . ,offset)
                             (end            . ,(+ offset num)))))
                 (set! offset (+ offset num))
                 out))
             (%list-fbos programs))
        '()))

(define (emit-shaders programs)
  (let ((shaders (list-shaders programs)))
    (cons (map (lambda (shdr)
                 `((type . ,(hans-primitive-enum 'SHADERS (shader-type shdr)))
                   (name . ,(hans-hash (shader-name shdr)))
                   (code . ,(hans-hash (shader-code shdr)))))
               shaders)
          (append
            (map shader-name shaders)
            (map shader-code shaders)))))

(define (emit-ring-buffers programs)
  (let ((objects (list-objects programs))
        (index   -1))
    (cons
      (fold (lambda (obj buffers)
              (let* ((res (hans-object-resources obj))
                     (name (assoc-ref res 'ring-buffer)))
                (if (not (eq? name #f))
                  (begin
                    (set! index (+ 1 index))
                    (append buffers `((
                      (producer . ,(hans-object-instance-id obj))
                      (name     . ,(hans-hash name))
                      (index    . ,index)))))
                  buffers)))
            '()
            objects)
      (remove (lambda (val) (eq? val #f))
              (map (compose (lambda (res)
                              (assoc-ref res 'ring-buffer))
                            hans-object-resources) objects)))))

(define (emit-audio-buffers programs)
  (cons
    (fold (lambda (obj buffers)
            (let ((rec (hans-object-rec obj))
                  (instance-id (hans-object-instance-id obj))
                  (item '()))
              (for-each (lambda (buff)
                          (set! buffers (append buffers `((
                            (object   . ,instance-id)
                            (name     . ,(hans-hash (audio-buffer-name buff)))
                            (channels . ,(audio-buffer-channels buff))
                            (size     . ,(audio-buffer-size buff)))))))
                        (object-record-audio-buffers rec))
              buffers))
          '()
          (list-objects programs))
    (map audio-buffer-name (list-audio-buffers programs))))

(define (make-strings strings)
  (let ((lengths '())
        (hashes  '())
        (buffer  ""))
    (for-each (lambda (str)
                (set! hashes (append hashes `(,(hans-hash str))))
                (set! lengths (append lengths `(,(string-length str))))
                (set! buffer (string-append buffer str)))
              (delete-duplicates strings))
    `((buffer  . ,buffer)
      (lengths . ,lengths)
      (hashes  . ,hashes))))

(define (backend-pass programs output options)
  (define strings '())
  (define out (hans-primitive-get output))

  (define (set-engine-data! key emitter)
    (let* ((res (emitter programs))
           (data (car res))
           (strs (cdr res)))
      (set! out (assq-set! out key data))
      (set! strings (append strings strs))))

  (set! out (assq-set! out 'settings options))
  (for-each (lambda (task)
              (set-engine-data! (car task) (cdr task)))
            `((plugins           . ,emit-libraries)
              (objects           . ,emit-objects)
              (objects_state     . ,emit-objects-state)
              (arguments         . ,emit-arguments)
              (parameters        . ,emit-parameters)
              (parameters_values . ,emit-parameters-values)
              (modulators        . ,emit-modulators)
              (chains            . ,emit-chains)
              (programs          . ,emit-programs)
              (registers         . ,emit-registers)
              (fbos              . ,emit-fbos)
              (fbos_attachments  . ,emit-fbos-attachments)
              (shaders           . ,emit-shaders)
              (ring_buffers      . ,emit-ring-buffers)
              (audio_buffers     . ,emit-audio-buffers)))

  (set-hans-primitive! output (assq-set! out 'strings (make-strings strings)))
  output)
